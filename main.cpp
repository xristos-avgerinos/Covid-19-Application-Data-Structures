#include <iostream>
#include <time.h>
#include <cstdlib>
#include <bits/stdc++.h>
using namespace std;

class Node {
public:
    int x;
    int y;
    Node *next;
    time_t my_time;
};
//Συναρτηση για τη δημιουργια καθε φορα νεου κομβου της αλυσιδας καποιου χρηστη
void addNewNode(Node **head, int new_x, int new_y, time_t new_my_time) {

    Node *new_node = new Node();
    Node *last = *head;
    new_node->x = new_x;
    new_node->y = new_y;
    new_node->my_time = new_my_time;
    new_node->next = NULL;

    //Αν ειναι ο πρωτος κομβος  της αλυσιδας
    if (*head == NULL) {
        *head = new_node;
        return;
    }
    while (last->next != NULL)
        last = last->next;
    last->next = new_node;
    //return;
}
//εμφανιση της αλυσιδας ενος χρηστη...βοηθητικη ειναι η συναρτηση για να ελεγχω τα αποτελεσματα
void printList(Node *node) {
    while (node != NULL) {
        cout << " x: " << node->x << " and y: " << node->y << " at: " << ctime(&node->my_time);
        node = node->next;
    }
}
//εμφανιση της αλυσιδας  του  καθε χρηστη ξεχωριστα...αλλη μια βοηθητικη  συναρτηση για να ελεγχω τα αποτελεσματα
void printList1(Node *Users[],int size) {
    for (int i = 0; i < size; i++) {
        cout << "The movement of "<<i+1<<" is" << endl;
        while (Users[i] != NULL) {
            cout << " x: " << Users[i]->x << " and y: " << Users[i]->y << " at: " << ctime(&Users[i]->my_time);
            Users[i] = Users[i]->next;
        }
    }
}
//συναρτηση που υπολογιζει την αποσταση μεταξυ δυο σημειων
double distance(int x1, int y1, int x2, int y2)
{
    return sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2) * 1.0);
}
//Αναζητηση  καποιου συγκεκριμενου κομβου οπου ξεκιναει απο μια συγκεκριμενη ωρα(σε δευτερολεπτα) συνηθως για την ευρεση του κομβου που ξεκιναει μια ημερα
Node * search(Node *node, time_t start) {
    while (node != NULL) {
        if (node->my_time == start) break;
        node = node->next;
    }
    return node;//επιστρεφει το κομβο που περιχει τη συγκεκριμενη μερα(start) ωστε να ξεκινησει απο κει η επαναληψη και να εχουμε την τροχια οποιασδηποτε μερας θελουμε (καποιου χρηστη)
}
//Συναρτηση πρωτη...τρεχει για καθε εναν υγιη χρηστη ξεχωριστα δινοντας την τροχια του
//δεχεται ως παραμετρους την τροχια ενος χρηστη, την ωρα(σε δευτερολεπτα) που ξεκιναει μια ημερα(ωστε να τρεξει μονο για τη ζητουμενη ημερα), την ωρα που τελειωνει η μερα αυτη(στην ουσια την ωρα που ξεκιναει η επομενη μερα) και την λιστα με τους ασθενεις
bool POSSIBLE_COVID_19_INFECTION(Node *node, time_t start, time_t finish, Node *Patients[],int size) {
    const int R = 2;//σταθερη ακτινα R
    const int T1 = 15*60;//μετατροπη των λεπτων σε δευτερολεπτα για να γινει η συγκριση
    const int T2 = 460*60;//μετατροπη των λεπτων σε δευτερολεπτα για να γινει η συγκριση
    Node *nodee;//βοηθητικο για να κραταω τιμες
    Node *temp_node;//βοηθητικο για να κραταω τιμες
    Node *pat_node;
    //cout<<ctime(&start)<<endl;
    //cout<<ctime(&finish)<<endl;

    //το τρεχω για καθε εναν ασθενη ξεχωριστα συγκρινοντας ολους τους κομβους του για μια συγκεκριμενη μερα με ολους τους κομβους του υγιη χρηστη με αναφορα αυτη τη μερα
    for (int i = 0; i < size; i++) {

        pat_node=search(Patients[i],start);//αναζητηση του κομβου του ασθενη οπου ξεκιναει η συγκεκριμενη μερα
        //cout<<Patients[i]<<endl;

        //τρεχω τον συγκεκριμενο ασθενη ελεγχοντας τον με τον υγιη  μεχρι η ωρα καταγραφης του ασθενη να φτασει στο τελος της ημερας.ελεγχω και τη συνθηκη (pat_node->next!=NULL)
        // στη περιπτωση που βρισκομαστε στην τελευταια μερα και ο επιμεξνος κομβος ειναι NULL(καθως αν ελεγχτει η συνθηκη (pat_node->my_time)< finish) θα βγαλει error )
        while ((pat_node->next!=NULL)&&(pat_node->my_time)< finish) {
            nodee=node;
            while ((nodee->next!=NULL)&&(nodee->my_time < finish)) {//τρεχω και ολη τη τροχια του υγιη με αναφορα την συγκεκριμενη ημερα
                if ((distance(pat_node->x, pat_node->y, nodee->x, nodee->y) <= R) && ((nodee->my_time - pat_node->my_time) >=0)
                    && ((nodee->my_time - pat_node->my_time)<=T2)) {  //ελεγχω αν η αποσταση των σημειων του υγιη με τον ασθενη  ειναι μικροτερη η ιση απο την ακτινα R καθως και αν η ωρα καταγραφης του ασθενη απεχει απο την ωρα καταγραφης του υγιη λιγοτερο απο T2 λεπτα(ο ελεγχος γινεται σε δευτερολεπτα)
                    int j;
                    temp_node = nodee; //περναω την ηδη υπαρχουσα τροχια του υγιη χρηστη απο τον συγκεκριμενο κομβο που βρισκεται απο το nodee στο temp_node ωστε να το τρεξω για τα επομενα T1 λεπτα και να δω αν οντως εμεινε αυτο το χρονικο διαστημα στη περιοχη
                    for (j = 0; j < T1 / 30; j++) { //διαιρω τα T1 λεπτα(που εχουν μετατραπει σε δευτερολπετα) με 30(καθως οι κομβοι της αλυσιδας αυξανονται ανα 30 δευτερολεπτα) ωστε να βρω το πληθος των επαναληψεων που θα τρεξει το for για να ελεγχτουν ολοι οι κομβοι του υγιη μεσα σε αυτο το χρονικο διαστημα
                        temp_node = temp_node->next;
                        if (/*(temp_node->my_time == finish)||*/temp_node==NULL) break;//ο ελεγχος συνεχιζεται και στην επομενη ημερα(εκτος αν ειναι η τελευταια μερα δηλαδη ο εποεμενος κομβος ειναι NULL) γιαυτο εχω σε σχολια τη πρωτη συνθηκη
                        if (distance(pat_node->x, pat_node->y, temp_node->x, temp_node->y) > R)
                            break; //αν μεσα σε αυτο το χρονικο διαστημα η αποσταση των σημειων του υγιη με τον ασθενη γινει μεγαλυτερη απο R τοτε βγαινει εκτος βροχου
                    }
                    if (j == T1 / 30 - 1){ //αν προσπελασε ολους τους κομβους για το χρονικο διαστημα T1 τοτε επιστρεφει true η συναρτηση
                        return true;
                    }
                }
                nodee=nodee->next;
            }
            pat_node = pat_node->next;
        }
    }
    return false;
}
//Συναρτηση δευτερη
//παιρνει ως παραμετρους τον πινακα με ολους τους χρηστες(υγιεις και ασθενης),την ωρα που αρχιζει και τελειωνει το χρονικο διαστημα(μιας συγκεκριμενης ημερας) ,που θα ελεγχτει(σε δευτερολεπτα),
// τις μεγιστες και ελαχιστες συντεταγμενες του τετραγωνου που θα ελεγχτει, και το ελαχιστο χρονικο διαστημα που θα πρεπει να εχει μεινει ο χρηστης στην περιοχη  ωστε να τον προσθεσουμε στο πληθος
int  FIND_CROWDED_PLACES(Node *USERS[],int size,time_t Time_interval_start,time_t Time_interval_finish,int max_x,int min_x, int max_y,int min_y, time_t Minimum_stay) {
    Node *user_node;
    Node *temp_node;
    int sum = 0;//το πληθος των χρηστων που μετραμε(που εμειναν στη περιοχη τηρωντας τις απαραιτητες προυποθεσεις) το οποιο θα επιστρεφει η συναρτηση για τη συγκεκριμενη μερα
    for (int i = 0; i < size; i++) {//το τρεχω για ολους τουε χρηστες

        user_node = search(USERS[i],Time_interval_start);//επιστρεφω τον κομβο οπου ξεκιναει το συγκεκριμενο χρονικο διαστημα(Time_interval_start) που θελουμε να ελεγξουμε για την συγκεκριμενη μερα
        //cout<<ctime(&user_node->my_time)<<endl;
        //cout<<ctime(&Time_interval_finish)<<endl;
        while ((user_node->my_time) < Time_interval_finish) {//το τρεχω μεχρι να φτασει στο τελος του χρονικου διαστηματος (Time_interval_finish)

            if ((user_node->x <= max_x) && (user_node->y <= max_y) && (user_node->x >= min_x) &&(user_node->y >= min_y)) { //ελεγχω αν οι συντεταγμενες του χρηστη βρισκονται εντος του τετραγωνου

                int j;
                temp_node = user_node;

                for (j = 0; j < Minimum_stay / 30; j++) { //ακολουθω την ιδια διαδικασια που ακολουθησα και στην πρωτη συναρτηση

                    temp_node = temp_node->next;
                    if (temp_node->my_time == Time_interval_finish) break;//δεν το ξεκαθαριζε η εκφωνηση αυτο(αν δηλαδη θα συνεχιζεται ο ελεγχος και την επομενη μερα)
                    if ((temp_node->x > max_x) || (temp_node->y > max_y) || (user_node->x < min_x) ||(user_node->y < min_y)) break;//αν ο χρηστης βγει εκτος συντεταγμενων του τετραγωνου τοτε βγαινουμε απο το βροχο
                }

                if (j == Minimum_stay / 30 - 1) {
                    sum = sum + 1;//Αν για τον απαιτουμενο χρονο Minimum_stay ο χρηστης εμεινε στη τετραγωνη περιοχη μεταξυ του χρονικου
                    // διαστηματος Time_interval_start-Time_interval_finish πριστεθεται αυτος ο χρηστης στο πληθος

                    break;//επιστρεφει στο πρωτο for και αλλαζει χρηστη για να κανει ελεγχο για αυτον τον νεο χρηστη
                }

            }
            //cout<<ctime(&user_node->my_time)<<endl;
            user_node = user_node->next;
        }
    }
    return sum;//επιστρεφουμε το πληθος
}
//βοηθητικη συναρτηση η οποια κανει insert ως πρωτο κομβο της αλυσιδας με τα συγκεκριμενα x,y,time που δινονται ως παραμετροι
void insert_as_first(Node** head_ref, int new_x,int new_y,time_t new_time)
{
    Node* new_node = new Node();

    new_node->x = new_x;
    new_node->y = new_y;
    new_node->my_time = new_time;

    new_node->next = (*head_ref);

    (*head_ref) = new_node;
}
//βοηθητικη συναρτηση η οποια κανει insert μετα απο καποιον συγκεκριμενο κομβο της αλυσιδας με τα συγκεκριμενα x,y,time που δινονται ως παραμετροι
void  insertAfter(Node* prev_node, int new_x,int new_y,time_t new_time)
{
    Node* new_node = new Node();

    new_node->x = new_x;
    new_node->y = new_y;
    new_node->my_time = new_time;

    new_node->next = prev_node->next;

    prev_node->next = new_node;
}
//Συναρτηση τριτη
//δεχεται ως παραμετρους την  ωρα που ξεκιναει η πρωτη και η τελευταια μερα σε δευτερολεπτα,την ωρα που ξεκιναει και τελειωνει η συγκεκριμενη μερα που μας ενδιαφερει σε δευτερολεπτα και την τροχια καποιου συγκεκριμενου χρηστη
void REPAIR( time_t first_day,time_t last_day,time_t start,time_t finish, Node *&node) {
    Node *temp_node;
    temp_node = search(node, start);//ψαχνουμε τον κομβο που ξεκιναει η συγκεκρμενη μερα στην τροχια του χρηστη
    if (temp_node == NULL) { //Αν επιστρεψει την τιμη NULL η παραπανω συναρτηση τοτε σημαινει οτι δεν εχει καταγραφει ο πρωτος κομβος της συγκεκριμενης ημερας οποτε θα πρεπει να τον εισαγουμε

        //εισαγωγη του πρωτου κομβου της συγκεκριμενης ημερας
        if (first_day == start) { //αν η ημερα που μας ενδιαφερει ειναι η πρωτη απ'ολες τοτε σημαινει οτι λειπει ο πρωτος κομβος της αλυσιδας οποτε κανουμε εισαγωγη ως πρωτο κομβο της αλυσιδας
            insert_as_first(&node, rand() % 20, rand() % 20, start);
            temp_node = node;//αρα τωρα ξεκιναει απο το πρωτο κομβο της ημερας που θελουμε που ειναι και ο πρωτος της αλυσιδας
        } else {//διαφορετικα αν ειναι ο πρωτος κομβος καποιας αλλης ημερας που λειπει κανουμε εισαγωγη μετα απο τον τελευταιο κομβο της προηγουμενης ημερας

            temp_node = search(node, start - 30);//ψαχνει τον τελευταιο κομβο της προηγουμενης ημερας απο αυτη που θελουμε να τρεξουμε
            insertAfter(temp_node, rand() % 20, rand() % 20, start);//κανει εισαγωγη μετα απο αυτον
            temp_node = temp_node->next;//αρα τωρα ξεκιναει απο το πρωτο κομβο της ημερας που θελουμε
        }
    }

    while ((temp_node->next!=NULL)&&(temp_node->next->my_time < finish )) {//το τρεχω μεχρι το τελος της ημερας..αν η ημερα που μας ενδιαφερει ιεναι η τελευταια τοτε ο βροχος επαναληψης σταματαει οταν ο επομενος κομβος ειναι ο NULL

        if (((temp_node->next->my_time) - (temp_node->my_time)) > 30) {//αν οι ωρες καταγραφης του κομβου που βρισκομαστε με τον επομενο απεχουν περισσοτερο απο 30 δευτερολεπτα κανουμε εισαγωγη νεου κομβου μετα απο αυτον που βρισκομαστε αυξανοντας την ωρα καταγραφης κατα 30 δευτερολεπτα
            insertAfter(temp_node, rand() % 20, rand() % 20, (temp_node->my_time) + 30);
        }

        temp_node = temp_node->next;

        //Ελεγχος για το αν εχει διαγραφει ο τελευταιος κομβος της ημερας(ειτε ειμαστε στην τελευταια ημερα ειτε οχι)
        if (temp_node->next != NULL) {//αν ο επομενος κομβος δεν ειναι ο NULL (αρα δεν ειμαστε στην τελευταια ημερα) τοτε
            // αν ο επομενος κομβος ειναι αυτος που περιεχει τον finish (δηλ την αρχη της επομενης ημερας) αλλα απεχει περισσοτερο απο 30 δευτερολεπτα απο τον προηγουμενο κομβο τοτε σημαινει οτι δεν εχει καταγραφει τελευταιος κομβος(ειτε και αλλοι κομβοι πριν τον τελευτοιο) και πρεπει να κανουμε εισαγωγη
            if ((temp_node->next->my_time == finish) && ((temp_node->next->my_time) - (temp_node->my_time)) > 30) {
                insertAfter(temp_node, rand() % 20, rand() % 20, (temp_node->my_time) + 30);
            }
        }
        else{
            //σημαινει οτι ειμαστε στη τελευταια ημερα απο ολες και ελεγχουμε αν λειπει ο τελευταιος κομβος(η και κομβοι πριν τον τελευταιο)...Αν λειπει εισαγουμε εναν
            // κομβο και επαναλαμβανουμε τη διαδικασια μεχρι να φτασουμε στο σωστο τελευταιο κομβο δηλαδη εκεινον που θα τελειωνει στα σωστα δευτερολεπτα(30 δευτερολεπτα πριν την εναρξη της θεωρητικα επομενης ημερας)
           if ((last_day - (temp_node->my_time)) > 30){
               insertAfter(temp_node, rand() % 20, rand() % 20, (temp_node->my_time) + 30);
           }
        }
    }
    //printList(node);
}
//Συναρτηση για την διαγραφη καπου κομβου απο την αλυσιδα καποιου χρηστη
void deleteNode(Node *head, Node *n)
{
    //Δεν κανω ελεγχους για το αν ο κομβος ειναι ο πρωτος κομβοσ καθως δεν προκειται ποτε θα δωθει ο πρωτος κομβος προς διαγραφη απο την συναρτηση SUMMARIZE_TRAJECTORY
    //βρισκω τον προηγουμενο κομβο
    Node *prev = head;
    while((prev->next != NULL )&&(prev->next != n)) //Ο ελεγχος  prev->next != NULL ειναι περιττος καθως δεν θα γινει ποτε NULL
        prev = prev->next;


    // αφαιρω τον κομβο απο τη λιστα
    prev->next = prev->next->next;

    // απελευθερωνω(διαγραφω) τον κομβο απο τη μνημη
    free(n);

}
//Συναρτηση τεσσερα
//δεχεται ως παραμετρους την αρχη και το τελος καθε ημερας που θελουμε να αντικαταστησουμε με μια συνοψη της και την τροχια του χρηστη
void SUMMARIZE_TRAJECTORY(time_t Summarize_Day_start,time_t Summarize_Day_finish, Node *node){
    const int R = 15;
    Node *user_node;
    Node *first_node;
    user_node = search(node, Summarize_Day_start);//αναζηταω τον κομβο που ξεκιναει η συγκεκριμενη ημερα που θελουμε να συρρικνωσουμε
    first_node=user_node;//το first node θα περιεχει καθε φορα τον κοβμο με τις συντεταγμενες που θα ελεγχονται με ολες τις επομενες συντεταγμενες των επομενων κομβων που θα απεχουν λιγοτερο απο R
    user_node=user_node->next;//ξεκιναω απο τον δευτερο κομβο της συγκεκριμενης ημερας καθως δεν θελω να διαγραψω ποτε τον πρωτο

    while ((user_node->my_time) < Summarize_Day_finish) {//το τρεχω μεχρι να φτασει στο τελος της ημερας (Summarize_Day_finish)
        if (distance(first_node->x,first_node->y,user_node->x,user_node->y)<R){
            deleteNode(first_node,user_node);//αν η αποσταση ειναι μικροτερη απο R απο τις συντεταγμενες του  first_node διαγραφω τον κομβο
        } else{
            //αλλιως αλλαζω το first_node με τον κομβο που περιεχει τις νεες συντεταγμενες
            first_node=user_node;
        }
        user_node=user_node->next;
    }
}
int main() {
    int atoma, days;
    atoma = 16;//δημιουργω 16 χρηστες θεωρωντας οτι οι πρωτοι 8 ειναι ασθενεις και οι υπολοιποι 8 υγιεις..εσεις για να το ελεγξετε καλο θα ηταν να βαλετε λιγοτερους χρηστες γιαν γινεται πιο ευκολα ο ελεγχος και να τρεχει πιο γρηγορα το προγραμμα
    //Δημιουργω ενα array που θα περιεχει ολους τους χρηστες
    Node *USERS[atoma];
    Node *nodee;
    cout << "give days ";//Καλο ειναι να δινετε λιγες ημερες
    cin >> days;
    time_t Array_for_days[days];//δημιουργω εναν πινακα που θα περιεχει την ωρα που αρχιζει η καθε ημερα σε δευτερολεπτα
    time_t my_time = time(NULL);//δινει τη τρεχουσα ωρα του υπολογιστη την ωρα που το τρεχουμε
    const time_t time_keeper=my_time;

    //το τρεχω για καθε ατομο για καθε ημερα και για καθε 30 δευτερολεπτα της ημερας
    for (int i = 0; i < atoma; i++) {
        Node *head = NULL;
        for (int j = 0; j < days; j++) {
            for (int k = 0; k < 86400; k += 30) {
                int x = rand() % 20;//παιρνω τυχαιους αριθμους απο το 1 εως το 20
                int y = rand() % 20;

                //αφηνω καποιους κομβους εκτος καταγραφης
                //Αν θελετε να δειτε αν δουλευει και στην περιπτωση που αποκλεισετε τον τελευταιο κομβο της καθε ημερας (δηλ (k!=86400-30))) θα πρεπει να βγαλετε την συνθηκη (k!=0) γιατι ο κωδικας μου δεν επιτρεπει να λειπει ταυτοχρονα και ο πρωτος και ο τελευταιος κομβος καθε ημερας
                //παντως δουλευει και για το αν λειπει ο πρωτος κομβος καθε ημερας και αν λειπει καποιος ενδιαμεσος η ο τελευταιος
                if ((k!=0)&&(k!=30)&&(k!=120)&&(k!=150)&&(k!=86400-60)&&(k!=86400-90)) addNewNode(&head, x, y, my_time);

                //τοποθετω στον πινακα με τις ημερες την αρχη καθε ημερας
                if ((k == 0) && (i == 0)) {
                    Array_for_days[j] = my_time;
                    //εχω δημιουργησει αλλη μια θεση(την τελευταια) η οποια θα περιεχει και την αρχη της επομενης ημερας απο την τελευταια για να μπορω να εκτελω τις συναρτησεις και για την τελευταια ημερα πιο ευκολα
                    if (j == (days - 1))
                        Array_for_days[j + 1] = my_time + 86400;
                }


                my_time = my_time + 30;//αυξανω ανα 30 δευτερολπετα τις ωρες καταγραφης που περναω στους κομβους μεσω της συναρτησης addNewNode
            }

            //cout<<ctime(&Array_for_days[j]);

            /*cout << "The movement of "<<i+1<<"st  in day "<<j+1<<" is " << endl;
            printList(nodee);*/

        }
        /*cout << "The movement of "<<i+1<<"st  in all days is " << endl;
        printList(head);*/

        my_time = time_keeper;//εφοσον αλλαζω ατομο του δινω παλι την αρχικη τιμη(τρεχων ωρα απο την στιγμη που αρχιζει να τρεχει το προγραμμα)
        
        //δημιουργω πινακα που θα περιεχει ολους τους χρηστες(υγιεις και ασθενης) οπου στις πρωτες 8 θεσεις θα περιεχει τους ασθενεις και στις υπολοιπες 8 τους υγιεις
        USERS[i] = head;
    }
    int DAYS_BEFORE=2;
    //εδω θα ξανα τρεξω για καθε ημερα ωστε να εκτελεσω τις συναρτησεις
    for (int l=0;l<days;l++) {
        //εκτελω την REPAIR για καθε ατομο την συγκεκριμενη ημερα l που διορθωνει τις τροχιες των χρηστων στη περιπτωση που εχουν χαθει κομβοι
        for (int a = 0; a < atoma; a++) {
            REPAIR(Array_for_days[0],Array_for_days[days],Array_for_days[l + 0], Array_for_days[l + 1], USERS[a]);
        }

        //καλω την POSSIBLE_COVID_19_INFECTION μονο για τους υγιεις χρηστες δηλαδη απο τον 9ο χρηστη μεχρι και τον 16ο(αφου οι πρωτοι 8 ειναι ασθενεις)
        for (int a = 8; a < atoma; a++) {
            nodee = search(USERS[a],Array_for_days[l]);//αποθηκευω στο nodee τον κομβο απο τον οποιο ξεκιναει η  τροχια του a χρηστη(υγιη) της συγκεκριμενης
            // ημερας που τρεχει στο l
            bool res = POSSIBLE_COVID_19_INFECTION(nodee, Array_for_days[l + 0], Array_for_days[l + 1], USERS, 8);//στελνω  τον πινακα USERS
            // μονο για τις οχτω πρωτες θεσεις του που περιεχει τους ασθενεις
            //cout<<res;
        }
        //κανω τον ελεγχω για τον αν η ημερα που βρισκομαστε ξεπερνα το συγκεκριμενο DAYS_BEFORE που εχουμε ορισει
        if (l >= DAYS_BEFORE) {
        for (int a = 0; a < atoma; a++) {
            SUMMARIZE_TRAJECTORY(Array_for_days[l-DAYS_BEFORE],Array_for_days[l-DAYS_BEFORE+1],USERS[a]);
        }
    }
        time_t Time_interval_start=Array_for_days[l]+14400; //το χρονικο διαστημα ξεκιναει απο την ωρα που ξεκιναει η l μερα συν 14400 δευτερολεπτα(4 ωρες)
        time_t Time_interval_finish=Time_interval_start+25200; //το χρονικο διαστημα τελειωνει απο την ωρα που ξεκιναει  συν 25200 δευτερολεπτα(7 ωρες).Αρα στο συνολο το χρονικο διαστημα ειναι 7 ωρες
        //αν θελετε να δειτε αν δουλευει βαλτε στο Minimum_stay μια μικρη τιμη:πχ 30 sec ή στο max_x,max_y το 20(το μεγιστο x,y δηλαδη που μπορει να υπαρχει) και στο min_x,min_y το 0(το ελαχιστο x,y δηλαδη που μπορει να υπαρχει) και εκτυπωστε
        // το r για μια ημερα...το αναμενομενο αποτελεσμα θα ειναι sum=8 δηλαδη οσο το πληθος των υγιων
        int r = FIND_CROWDED_PLACES(USERS,atoma,Time_interval_start,Time_interval_finish,(rand() % 10)+10,rand() % 10,(rand() % 10)+10,rand() % 10,7200);
        //cout<<r;
    }
    //1ος τροπος εμφανισης της αλυσιδας καθε χρηστη
    //επειδη ειναι τεραστια αμα θελετε να το τρεξετε βγαλτε το απο σχολια και βαλτε μικροτερο ευρος χρηστων η δευτερολεπτων(δηλαδη αντι για 86400 βαλτε 600)
    /*for (int a = 0; a < atoma; a++) {
        cout << "The movement of " << a + 1 << "st  in all days is " << endl;
        printList(USERS[a]);
    }*/
    //2ος τροπος εμφανισης της αλυσιδας καθε χρηστη...πιο γρηγορος
    //επειδη ειναι τεραστια αμα θελετε να το τρεξετε βγαλτε το απο σχολια και βαλτε μικροτερο ευρος χρηστων η δευτερολεπτων(δηλαδη αντι για 86400 βαλτε 600)
    //printList1(USERS,atoma);



    /* for (int l = 0; l < 8; l++) {
          cout<<Patients[l]->x<<"   ";
      }*/

    /* for (int l=0;l<days;l++)
         cout<<ctime(&Array_for_days[l])<<endl;*/
}